rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the resource
    function isOwner() {
      return request.auth.uid == resource.data.userId;
    }
    
    function isValidDate(date) {
      return date is timestamp;
    }
    
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Adicione uma regra específica para os dados do Google Calendar
      match /googleCalendar/{document=**} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    match /tasks/{taskId} {
      function isValidTask() {
        let incoming = request.resource.data;
        return incoming.title is string
          && incoming.userId == request.auth.uid
          && incoming.columnId is string
          && incoming.position is number
          && (incoming.tags == null || incoming.tags is list);
      }

      allow read: if request.auth != null && (
        resource == null || resource.data.userId == request.auth.uid
      );
      allow create: if request.auth != null 
        && request.resource.data.userId == request.auth.uid;
      allow update: if request.auth != null 
        && resource.data.userId == request.auth.uid
        && (
          // Permite atualização parcial para tags
          request.resource.data.diff(resource.data).affectedKeys()
            .hasOnly(['tags', 'updatedAt'])
          || isValidTask() // Ou validação completa para outras atualizações
        );
      allow delete: if request.auth != null 
        && resource.data.userId == request.auth.uid;
    }
    
    match /subjects/{subjectId} {
      function isValidSubject() {
        let incoming = request.resource.data;
        return incoming.name is string
          && incoming.totalHours is number
          && incoming.type1.hours is number
          && incoming.type1.hoursPerClass is number
          && incoming.type1.absences is number
          && incoming.type2.hours is number
          && incoming.type2.hoursPerClass is number
          && incoming.type2.absences is number
          && incoming.hasMultipleTypes is bool
          && incoming.maxAbsencePercentage is number
          && incoming.userId is string
          && isValidDate(incoming.createdAt);
      }

      allow read: if isAuthenticated() && (
        resource == null || resource.data.userId == request.auth.uid
      );
      allow create: if isAuthenticated() 
        && request.resource.data.userId == request.auth.uid
        && isValidSubject();
      allow update: if isAuthenticated() 
        && resource.data.userId == request.auth.uid
        && isValidSubject();
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    match /pomodoro_sessions/{sessionId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }
    
    match /settings/{userId} {
      function isValidSettings() {
        let incoming = request.resource.data;
        return incoming.userId is string
          && incoming.theme is string
          && incoming.notifications is bool
          && incoming.pomodoroSettings.focusTime is number
          && incoming.pomodoroSettings.shortBreakTime is number
          && incoming.pomodoroSettings.longBreakTime is number
          && incoming.pomodoroSettings.sessionsUntilLongBreak is number;
      }

      allow read: if isOwner(userId);
      allow write: if isOwner(userId) && isValidSettings();
    }
    
    match /notes/{noteId} {
      function isValidNote() {
        let incoming = request.resource.data;
        return incoming.title is string
          && incoming.content is string
          && incoming.topicId is string
          && incoming.userId is string
          && isValidDate(incoming.createdAt)
          && isValidDate(incoming.updatedAt);
      }

      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() 
        && request.resource.data.userId == request.auth.uid
        && isValidNote();
      allow update: if isAuthenticated() 
        && resource.data.userId == request.auth.uid
        && isValidNote();
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    match /topics/{topicId} {
      function isValidTopic() {
        let incoming = request.resource.data;
        return incoming.name is string
          && incoming.userId is string
          && isValidDate(incoming.createdAt);
      }

      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() 
        && request.resource.data.userId == request.auth.uid
        && isValidTopic();
      allow update: if isAuthenticated() 
        && resource.data.userId == request.auth.uid
        && isValidTopic();
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    match /studyTopics/{topicId} {
      function isValidStudyTopic() {
        let incoming = request.resource.data;
        return incoming.title is string
          && incoming.userId == request.auth.uid
          && incoming.progress is number
          && (incoming.topics is list || incoming.topics == null)
          && (incoming.examDate is string || incoming.examDate == null)
          && (incoming.position is number)
          && (incoming.createdAt is string || incoming.createdAt == null)
          && (incoming.updatedAt is string || incoming.updatedAt == null);
      }

      allow read: if isAuthenticated() && (
        resource == null || resource.data.userId == request.auth.uid
      );
      
      allow create: if isAuthenticated() 
        && request.resource.data.userId == request.auth.uid
        && isValidStudyTopic();
      
      allow update: if isAuthenticated() 
        && isOwner()
        && (
          request.resource.data.diff(resource.data).affectedKeys()
            .hasOnly(['progress', 'topics', 'updatedAt', 'position'])
          || isValidStudyTopic()
        );
      
      allow delete: if isAuthenticated() && isOwner();
    }
    
    match /tags/{tagId} {
      function isValidTag() {
        let incoming = request.resource.data;
        return incoming.name is string
          && incoming.color is string
          && incoming.userId is string
          && (incoming.createdAt == null || isValidDate(incoming.createdAt));
      }

      allow read: if isAuthenticated() && (
        resource == null || resource.data.userId == request.auth.uid
      );
      allow create: if isAuthenticated() 
        && request.resource.data.userId == request.auth.uid
        && isValidTag();
      allow update: if isAuthenticated() 
        && resource.data.userId == request.auth.uid
        && isValidTag();
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    match /boards/{boardId} {
      function isValidBoard() {
        let incoming = request.resource.data;
        return incoming.title is string
          && incoming.userId is string
          && isValidDate(incoming.createdAt)
          && isValidDate(incoming.updatedAt);
      }

      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() 
        && request.resource.data.userId == request.auth.uid
        && isValidBoard();
      allow update: if isAuthenticated() 
        && resource.data.userId == request.auth.uid
        && isValidBoard();
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    match /columns/{columnId} {
      function isValidColumn() {
        let incoming = request.resource.data;
        return incoming.title is string
          && incoming.userId is string
          && incoming.position is number
          && (incoming.createdAt == null || isValidDate(incoming.createdAt))
          && (incoming.updatedAt == null || isValidDate(incoming.updatedAt));
      }

      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() 
        && request.resource.data.userId == request.auth.uid
        && isValidColumn();
      allow update: if isAuthenticated() 
        && resource.data.userId == request.auth.uid
        && (
          // Permite atualização parcial para reordenação
          request.resource.data.diff(resource.data).affectedKeys()
            .hasOnly(['position', 'updatedAt', 'title'])
          || isValidColumn() // Ou validação completa para outras atualizações
        );
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
  }
} 